<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flowchart Step & Branch Editor Prototype</title>
<style>
  body { font-family: sans-serif; margin: 20px; background: #f4f4f4; }
  h1 { margin-bottom: 10px; }
  .controls { margin-bottom: 10px; }
  button { margin-right: 5px; }
  #steps-container { display: flex; flex-direction: column; gap: 10px; }
  .step-card { background: #fff; padding: 10px; border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); position: relative; }
  .branches-container { margin-top: 10px; padding-left: 10px; border-left: 2px dashed #ccc; }
  .branch-row { display: flex; gap: 5px; margin-bottom: 5px; align-items: center; }
  input, select { padding: 4px; }
  .dragging { opacity: 0.5; }
  svg { position: absolute; top: 0; left: 0; pointer-events: none; overflow: visible; }
</style>
</head>
<body>

<h1>Flowchart Step & Branch Editor</h1>

<div class="controls">
  <button onclick="addStep()">+ Add Step</button>
  <button onclick="undo()">⎌ Undo</button>
  <button onclick="redo()">⎌ Redo</button>
</div>

<div id="steps-container"></div>
<svg id="connections"></svg>

<script>
let store = { steps: [] };
const history = [];
let historyPointer = -1;
const MAX_HISTORY = 50;

function pushHistory() {
  history.splice(historyPointer + 1);
  history.push(JSON.stringify(store));
  if (history.length > MAX_HISTORY) history.shift();
  historyPointer = history.length - 1;
}

function undo() {
  if(historyPointer <= 0) return;
  historyPointer--;
  store = JSON.parse(history[historyPointer]);
  renderAll();
}

function redo() {
  if(historyPointer >= history.length - 1) return;
  historyPointer++;
  store = JSON.parse(history[historyPointer]);
  renderAll();
}

function addStep() {
  pushHistory();
  const newStep = { id: Date.now().toString(), title: "New Step", branches: [] };
  store.steps.push(newStep);
  renderAll();
}

function deleteStep(stepId) {
  pushHistory();
  store.steps = store.steps.filter(s => s.id !== stepId);
  store.steps.forEach(s => s.branches.forEach(b => { if(b.target === stepId) b.target = ""; }));
  renderAll();
}

function addBranch(stepId) {
  pushHistory();
  const step = store.steps.find(s => s.id === stepId);
  step.branches.push({ id: Date.now().toString(), condition: "", target: "" });
  renderAll();
}

function deleteBranch(stepId, branchId) {
  pushHistory();
  const step = store.steps.find(s => s.id === stepId);
  step.branches = step.branches.filter(b => b.id !== branchId);
  renderAll();
}

function updateStepTitle(stepId, value) {
  pushHistory();
  const step = store.steps.find(s => s.id === stepId);
  step.title = value;
  renderConnections();
}

function updateBranch(stepId, branchId, field, value) {
  pushHistory();
  const step = store.steps.find(s => s.id === stepId);
  const branch = step.branches.find(b => b.id === branchId);
  branch[field] = value;
  renderConnections();
}

function renderAll() {
  const container = document.getElementById("steps-container");
  container.innerHTML = "";
  
  store.steps.forEach((step, idx) => {
    const stepDiv = document.createElement("div");
    stepDiv.className = "step-card";
    stepDiv.draggable = true;
    stepDiv.dataset.id = step.id;

    stepDiv.addEventListener('dragstart', e => {
      e.dataTransfer.setData('text/plain', step.id);
      stepDiv.classList.add('dragging');
    });
    stepDiv.addEventListener('dragend', () => {
      stepDiv.classList.remove('dragging');
    });
    stepDiv.addEventListener('dragover', e => e.preventDefault());
    stepDiv.addEventListener('drop', e => {
      const draggedId = e.dataTransfer.getData('text/plain');
      if(draggedId === step.id) return;
      pushHistory();
      const draggedIndex = store.steps.findIndex(s => s.id === draggedId);
      const targetIndex = store.steps.findIndex(s => s.id === step.id);
      const [draggedStep] = store.steps.splice(draggedIndex, 1);
      store.steps.splice(targetIndex, 0, draggedStep);
      renderAll();
    });

    const titleInput = document.createElement("input");
    titleInput.value = step.title;
    titleInput.oninput = e => updateStepTitle(step.id, e.target.value);
    stepDiv.appendChild(titleInput);

    const deleteBtn = document.createElement("button");
    deleteBtn.textContent = "✕ Delete Step";
    deleteBtn.onclick = () => deleteStep(step.id);
    stepDiv.appendChild(deleteBtn);

    const branchContainer = document.createElement("div");
    branchContainer.className = "branches-container";

    const addBranchBtn = document.createElement("button");
    addBranchBtn.textContent = "+ Add Branch";
    addBranchBtn.onclick = () => addBranch(step.id);
    branchContainer.appendChild(addBranchBtn);

    step.branches.forEach(branch => {
      const row = document.createElement("div");
      row.className = "branch-row";

      const conditionInput = document.createElement("input");
      conditionInput.placeholder = "Condition";
      conditionInput.value = branch.condition;
      conditionInput.oninput = e => updateBranch(step.id, branch.id, 'condition', e.target.value);
      row.appendChild(conditionInput);

      const targetSelect = document.createElement("select");
      const emptyOpt = document.createElement("option");
      emptyOpt.value = "";
      emptyOpt.textContent = "→ Next Step";
      targetSelect.appendChild(emptyOpt);
      store.steps.forEach(s => {
        const opt = document.createElement("option");
        opt.value = s.id;
        opt.textContent = s.title;
        if(s.id === branch.target) opt.selected = true;
        targetSelect.appendChild(opt);
      });
      targetSelect.onchange = e => updateBranch(step.id, branch.id, 'target', e.target.value);
      row.appendChild(targetSelect);

      const delBranchBtn = document.createElement("button");
      delBranchBtn.textContent = "✕";
      delBranchBtn.onclick = () => deleteBranch(step.id, branch.id);
      row.appendChild(delBranchBtn);

      branchContainer.appendChild(row);
    });

    stepDiv.appendChild(branchContainer);
    container.appendChild(stepDiv);
  });

  renderConnections();
}

// Draw simple SVG lines between steps based on branch targets
function renderConnections() {
  const svg = document.getElementById("connections");
  svg.innerHTML = "";
  store.steps.forEach(step => {
    const stepDiv = document.querySelector(`.step-card[data-id='${step.id}']`);
    const rect = stepDiv.getBoundingClientRect();
    const startX = rect.right - 10;
    const startY = rect.top + rect.height/2 + window.scrollY;

    step.branches.forEach(branch => {
      if(!branch.target) return;
      const targetDiv = document.querySelector(`.step-card[data-id='${branch.target}']`);
      if(!targetDiv) return;
      const tRect = targetDiv.getBoundingClientRect();
      const endX = tRect.left + 10;
      const endY = tRect.top + tRect.height/2 + window.scrollY;

      const line = document.createElementNS("http://www.w3.org/2000/svg","line");
      line.setAttribute("x1", startX);
      line.setAttribute("y1", startY);
      line.setAttribute("x2", endX);
      line.setAttribute("y2", endY);
      line.setAttribute("stroke","#007bff");
      line.setAttribute("stroke-width","2");
      svg.appendChild(line);
    });
  });
}

// Initial render
renderAll();
window.addEventListener('resize', renderConnections);
window.addEventListener('scroll', renderConnections);
</script>

</body>
</html>
