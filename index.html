<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flowchart Canvas Editor</title>
<style>
  body { font-family: sans-serif; margin: 0; background: #f4f4f4; overflow: hidden; }
  #toolbar { padding: 10px; background: #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.1); position: fixed; width: 100%; z-index: 10; }
  button { margin-right: 5px; padding: 5px 10px; }
  #canvas { position: absolute; top: 50px; bottom: 0; left: 0; right: 0; overflow: auto; }
  .step-card { position: absolute; width: 160px; background: #fff; padding: 10px; border-radius: 6px; box-shadow: 0 2px 5px rgba(0,0,0,0.15); cursor: grab; }
  .branch-row { display: flex; gap: 5px; margin-top: 5px; align-items: center; }
  input, select { padding: 4px; font-size: 0.9em; }
  svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
</style>
</head>
<body>

<div id="toolbar">
  <button onclick="addStep()">+ Add Step</button>
  <button onclick="undo()">⎌ Undo</button>
  <button onclick="redo()">⎌ Redo</button>
</div>

<div id="canvas"></div>
<svg id="connections"></svg>

<script>
let store = { steps: [] };
const history = [];
let historyPointer = -1;
const MAX_HISTORY = 50;

function pushHistory() {
  history.splice(historyPointer + 1);
  history.push(JSON.stringify(store));
  if(history.length > MAX_HISTORY) history.shift();
  historyPointer = history.length - 1;
}

function undo() {
  if(historyPointer <= 0) return;
  historyPointer--;
  store = JSON.parse(history[historyPointer]);
  renderAll();
}

function redo() {
  if(historyPointer >= history.length - 1) return;
  historyPointer++;
  store = JSON.parse(history[historyPointer]);
  renderAll();
}

function addStep() {
  pushHistory();
  const newStep = { 
    id: Date.now().toString(), 
    title: "New Step", 
    branches: [], 
    x: 50 + Math.random() * 300, 
    y: 50 + Math.random() * 200 
  };
  store.steps.push(newStep);
  renderAll();
}

function deleteStep(stepId) {
  pushHistory();
  store.steps = store.steps.filter(s => s.id !== stepId);
  store.steps.forEach(s => s.branches.forEach(b => { if(b.target === stepId) b.target = ""; }));
  renderAll();
}

function addBranch(stepId) {
  pushHistory();
  const step = store.steps.find(s => s.id === stepId);
  step.branches.push({ id: Date.now().toString(), condition: "", target: "" });
  renderAll();
}

function deleteBranch(stepId, branchId) {
  pushHistory();
  const step = store.steps.find(s => s.id === stepId);
  step.branches = step.branches.filter(b => b.id !== branchId);
  renderAll();
}

function updateStepTitle(stepId, value) {
  pushHistory();
  const step = store.steps.find(s => s.id === stepId);
  step.title = value;
  renderConnections();
}

function updateBranch(stepId, branchId, field, value) {
  pushHistory();
  const step = store.steps.find(s => s.id === stepId);
  const branch = step.branches.find(b => b.id === branchId);
  branch[field] = value;
  renderConnections();
}

function renderAll() {
  const canvas = document.getElementById("canvas");
  canvas.innerHTML = "";
  
  store.steps.forEach(step => {
    const div = document.createElement("div");
    div.className = "step-card";
    div.style.left = step.x + "px";
    div.style.top = step.y + "px";
    div.dataset.id = step.id;

    const titleInput = document.createElement("input");
    titleInput.value = step.title;
    titleInput.oninput = e => updateStepTitle(step.id, e.target.value);
    div.appendChild(titleInput);

    const deleteBtn = document.createElement("button");
    deleteBtn.textContent = "✕ Delete";
    deleteBtn.onclick = () => deleteStep(step.id);
    div.appendChild(deleteBtn);

    const addBranchBtn = document.createElement("button");
    addBranchBtn.textContent = "+ Branch";
    addBranchBtn.onclick = () => addBranch(step.id);
    div.appendChild(addBranchBtn);

    step.branches.forEach(branch => {
      const row = document.createElement("div");
      row.className = "branch-row";

      const condInput = document.createElement("input");
      condInput.placeholder = "Condition";
      condInput.value = branch.condition;
      condInput.oninput = e => updateBranch(step.id, branch.id, 'condition', e.target.value);
      row.appendChild(condInput);

      const targetSelect = document.createElement("select");
      const emptyOpt = document.createElement("option");
      emptyOpt.value = "";
      emptyOpt.textContent = "→ Next Step";
      targetSelect.appendChild(emptyOpt);
      store.steps.forEach(s => {
        const opt = document.createElement("option");
        opt.value = s.id;
        opt.textContent = s.title;
        if(s.id === branch.target) opt.selected = true;
        targetSelect.appendChild(opt);
      });
      targetSelect.onchange = e => updateBranch(step.id, branch.id, 'target', e.target.value);
      row.appendChild(targetSelect);

      const delBranchBtn = document.createElement("button");
      delBranchBtn.textContent = "✕";
      delBranchBtn.onclick = () => deleteBranch(step.id, branch.id);
      row.appendChild(delBranchBtn);

      div.appendChild(row);
    });

    // Dragging
    let offsetX, offsetY;
    div.addEventListener('mousedown', e => {
      offsetX = e.offsetX;
      offsetY = e.offsetY;
      function onMouseMove(ev) {
        div.style.left = (ev.pageX - offsetX) + "px";
        div.style.top = (ev.pageY - offsetY) + "px";
        const s = store.steps.find(st => st.id === step.id);
        s.x = ev.pageX - offsetX;
        s.y = ev.pageY - offsetY;
        renderConnections();
      }
      function onMouseUp() {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
        pushHistory();
      }
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });

    canvas.appendChild(div);
  });

  renderConnections();
}

// Draw curved connections
function renderConnections() {
  const svg = document.getElementById("connections");
  svg.innerHTML = "";
  store.steps.forEach(step => {
    const fromDiv = document.querySelector(`.step-card[data-id='${step.id}']`);
    if(!fromDiv) return;
    const fromRect = fromDiv.getBoundingClientRect();
    const fromX = fromRect.left + fromRect.width / 2 + window.scrollX;
    const fromY = fromRect.top + fromRect.height / 2 + window.scrollY;

    step.branches.forEach(branch => {
      if(!branch.target) return;
      const toDiv = document.querySelector(`.step-card[data-id='${branch.target}']`);
      if(!toDiv) return;
      const toRect = toDiv.getBoundingClientRect();
      const toX = toRect.left + toRect.width / 2 + window.scrollX;
      const toY = toRect.top + toRect.height / 2 + window.scrollY;

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      const dx = Math.abs(toX - fromX)/2;
      const dy = Math.abs(toY - fromY)/2;
      const curve = `M${fromX},${fromY} C${fromX+dx},${fromY} ${toX-dx},${toY} ${toX},${toY}`;
      path.setAttribute("d", curve);
      path.setAttribute("stroke","#007bff");
      path.setAttribute("stroke-width","2");
      path.setAttribute("fill","none");
      svg.appendChild(path);
    });
  });
}

renderAll();
window.addEventListener('resize', renderConnections);
window.addEventListener('scroll', renderConnections);
</script>

</body>
</html>
